/* source file, generated by gaigen */


#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "e3ga.h"

const int e3gai_map_gp_a[16] = {
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  
};
const int e3gai_map_gp_b[16] = {
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  
};
/*const*/ e3gai_optFuncPtr e3gai_func_gp[1 * 1] = { /* pointers to optimized functions for doing 'gp' */
	(e3gai_optFuncPtr)e3gai_general_gp 
};
const int e3gai_resultUsage_gp[1 * 1]  = { /* grade & memory usage of results of 'gp' */
-1  
};

const int e3gai_map_lcont_a[16] = {
	1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1  
};
const int e3gai_map_lcont_b[16] = {
	4, 4, 2, 4, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4  
};
/*const*/ e3gai_optFuncPtr e3gai_func_lcont[2 * 3] = { /* pointers to optimized functions for doing 'lcont' */
	e3gai_opt_02_lcont_04,
	(e3gai_optFuncPtr)e3gai_general_lcont,
	e3gai_opt_02_lcont_02,
	(e3gai_optFuncPtr)e3gai_general_lcont,
	(e3gai_optFuncPtr)e3gai_general_lcont,
	(e3gai_optFuncPtr)e3gai_general_lcont 
};
const int e3gai_resultUsage_lcont[2 * 3]  = { /* grade & memory usage of results of 'lcont' */
0x32, -1, 
0x11, -1, 
-1, -1  
};

const int e3gai_map_op_a[16] = {
	3, 0, 1, 3, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3  
};
const int e3gai_map_op_b[16] = {
	4, 8, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8  
};
/*const*/ e3gai_optFuncPtr e3gai_func_op[4 * 3] = { /* pointers to optimized functions for doing 'op' */
	e3gai_opt_01_op_02,
	e3gai_opt_02_op_02,
	e3gai_opt_04_op_02,
	(e3gai_optFuncPtr)e3gai_general_op,
	e3gai_opt_zero_result,
	(e3gai_optFuncPtr)e3gai_general_op,
	(e3gai_optFuncPtr)e3gai_general_op,
	(e3gai_optFuncPtr)e3gai_general_op,
	(e3gai_optFuncPtr)e3gai_general_op,
	(e3gai_optFuncPtr)e3gai_general_op,
	(e3gai_optFuncPtr)e3gai_general_op,
	(e3gai_optFuncPtr)e3gai_general_op 
};
const int e3gai_resultUsage_op[4 * 3]  = { /* grade & memory usage of results of 'op' */
0x32, 0x34, 0x18, -1, 
0x0, -1, -1, -1, 
-1, -1, -1, -1  
};

const int e3gai_map_scp_a[16] = {
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  
};
const int e3gai_map_scp_b[16] = {
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  
};
/*const*/ e3gai_optFuncPtr e3gai_func_scp[1 * 1] = { /* pointers to optimized functions for doing 'scp' */
	(e3gai_optFuncPtr)e3gai_general_scp 
};
const int e3gai_resultUsage_scp[1 * 1]  = { /* grade & memory usage of results of 'scp' */
-1  
};

int e3gai_expansionTable_gp[] = {
-1,
0, 9, 18, 27, 36, 45, 54, 63, -1,
1, 8, 22, 93, 39, 107, 50, 60, -1,
2, 78, 16, 28, 35, 47, 113, 61, -1,
3, 13, 84, 24, 98, 41, 55, 62, -1,
68, 79, 19, 90, 32, 46, 117, 57, -1,
69, 75, 87, 25, 102, 40, 52, 58, -1,
70, 10, 81, 95, 37, 108, 48, 59, -1,
71, 76, 85, 94, 33, 42, 51, 56, -1
};

const char *e3gai_basisElementNames[8] = {
"1",
"e1",
"e2",
"e3",
"e2^e3",
"e3^e1",
"e1^e2",
"e1^e2^e3"
};

int e3gai_gradeSize[4] = {1, 3, 3, 1};
int e3gai_mvSize[16] = {0, 1, 3, 4, 3, 4, 6, 7, 1, 2, 4, 5, 4, 5, 7, 8};

const int e3gai_bevt0[1] = {-1};
const int e3gai_bevt1[3] = {0, 1, 2};
const int e3gai_bevt2[3] = {1, 2, 0};
const int e3gai_bevt3[1] = {0};
const int *e3gai_bevt[4] = { // bevt = basis element vector table
	e3gai_bevt0,
	e3gai_bevt1,
	e3gai_bevt2,
	e3gai_bevt3
};
const int e3gai_newBevt[8] = { // bevt = basis element vector table
	0, 1, 2, 4, 6, 5, 3, 7
};

const int e3gai_omct[24] = { // omct = Outer Morphism Construction Table
	-1, -1, 0,
	1, -1, 1,
	2, -1, 1,
	3, -1, 1,
	2, 3, 1,
	1, 3, -1,
	1, 2, 1,
	4, 1, 1
};

e3gai e3gai::e1(GRADE1, 1.0f, 0.0f, 0.0f);
e3gai e3gai::e2(GRADE1, 0.0f, 1.0f, 0.0f);
e3gai e3gai::e3(GRADE1, 0.0f, 0.0f, 1.0f);
e3gai *e3gai::bv[3] = {&e3gai::e1, &e3gai::e2, &e3gai::e3};
e3gai e3gai::I(GRADE3, 1.0f);
e3gai e3gai::Ii(GRADE3, 1.0f); //todo: incorrect inverse pseudoscalar!!

const int e3gai::dim = 3;
const int e3gai::nbCoor = 8;

e3gai::e3gai() {
	usage = 0;
	memset(c, 0,sizeof(float) * 8);
}

e3gai::e3gai(const e3gai &a) {
	usage = 0;
	copy(a);
}

e3gai::e3gai(int gradeUsage, const float *coordinates) {
	usage = 0;
	set(gradeUsage, coordinates);
}

e3gai::~e3gai() {
	setUsage(0);
}

e3gai::e3gai(int grade, float c0) {
	usage = 0;
	set(grade, c0);
}

e3gai::e3gai(int grade, float c0, float c1, float c2) {
	usage = 0;
	set(grade, c0, c1, c2);
}

void e3gai::null() {
	setUsage(0);
}

void e3gai::set(int gradeUsage, const float *coordinates) {
	setUsage((e3gai_mvSize[gradeUsage] << 4) | gradeUsage);
	e3gai_copy(c, coordinates, e3gai_mvSize[gradeUsage]);
}

void e3gai::setScalar(const float coordinates[1]) {
	setUsage(17);
	e3gai_copy(c, coordinates, 1);
}

void e3gai::setVector(const float coordinates[3]) {
	setUsage(50);
	e3gai_copy(c, coordinates, 3);
}

void e3gai::set2Vector(const float coordinates[3]) {
	setUsage(52);
	e3gai_copy(c, coordinates, 3);
}

void e3gai::set3Vector(const float coordinates[1]) {
	setUsage(24);
	e3gai_copy(c, coordinates, 1);
}

int e3gai::set(int grade, float c0) {
	setUsage(grade | (e3gai_mvSize[grade] << 4));
	c[0] = c0;
	return 0;
}

int e3gai::set(int grade, float c0, float c1, float c2) {
	setUsage(grade | (e3gai_mvSize[grade] << 4));
	c[0] = c0;
	c[1] = c1;
	c[2] = c2;
	return 0;
}

const char *e3gai::string(const char *prec /*= NULL*/) const {
	// todo: this whole function is not very (mt-)safe
	static char tmpResult[1024]; 

	const int maxResult = 16; 
	static char *result[maxResult];
	static int currentResult = 0;

	char *rBuf = tmpResult;
	int i, j, k = 0, ia = 0, gu = gradeUsage(), s = e3gai_mvSize[gu], p = 0;
	char buf[32];	

	if (prec == NULL) prec = "%2.2f";
	sprintf(buf, "%cs%s%cs%cs", '%', prec, '%', '%');
	if (!gu) rBuf += sprintf(rBuf, "0");
	else {
		for (i = 0; i <= 3; i++)
			if (gu & (1 << i)) {
				for (j = 0; j < e3gai_gradeSize[i]; j++) {
					if (c[k] != 0.0) {
						rBuf += sprintf(rBuf, buf, (p) ? " + " : "", c[k], (i) ? "*" : "", (i) ? e3gai_basisElementNames[ia] : "");
						p = 1;
					}
					k++; ia++;
				}
			}
			else ia += e3gai_gradeSize[i];
	}

	k = strlen(tmpResult) + 1;
	rBuf = result[currentResult] = (char*)realloc(result[currentResult], k);
	currentResult = (currentResult + 1) % maxResult;

	if (rBuf == NULL) {
		printf("Memory allocation failure for %d bytes\n", k);
		return tmpResult; // at least return something...
	}
	else {
		memcpy(rBuf, tmpResult, k);
		return rBuf;
	}
}

void e3gai::print(const char *text /*= NULL*/, const char *prec /*= NULL*/) const {
	fprint(stdout, text, prec);
}

void e3gai::fprint(FILE *F, const char *text /*= NULL*/, const char *prec /*= NULL*/) const {
	if (text) fprintf(F, text);
	fprintf(F, "%s\n", string(prec));
}

void e3gai::copy(const e3gai &a) {
	setUsage(a.usage);
	e3gai_copy(c, a.c, e3gai_mvSize[a.gradeUsage()]);
}

void e3gai::compress() { // (float limit) {
	float cc[8];
	int i, j, ia = 0, ib = 0, gu = gradeUsage(), gu2 = 0, f, s;
	for (i = 0; i < 4; i++) {
		if (!(gu & (1 << i))) continue;

		s = e3gai_gradeSize[i];
		j = ia + s;
		f = 0;
		for (; ia < j; ia++)
		if (c[ia] != 0.0) {f = 1; break;}	//if ((c[ia] > limit) || (c[ia] < -limit)) {f = 1; break;}
		ia = j;
		if (f) {
			e3gai_copy(cc + ib, c + ia - s, s);
			ib += s;
			gu2 |= (1 << i);
		}
	}
	if (gu2 != gu) set(gu2, cc);
}

void e3gai::reverse(const e3gai &a) {
	float *pc[4];
	copy(a);
	if (!(a.gradeUsage() & 12)) return;
	expand( (const float**) pc);
	e3gai_reverse(pc);
}

void e3gai::cliffordConjugate(const e3gai &a) {
	float *pc[4];
	copy(a);
	if (!(a.gradeUsage() & 6)) return;
	expand( (const float**) pc);
	e3gai_cliffordConjugate(pc);
}

void e3gai::gradeInvolution(const e3gai &a) {
	float *pc[4];
	copy(a);
	if (!(a.gradeUsage() & 10)) return;
	expand( (const float**) pc);
	e3gai_involution(pc);
}

void e3gai::negate(const e3gai &a) {
	setUsage(a.usage);
	e3gai_negate(c, a.c, e3gai_mvSize[a.gradeUsage()]);
}

void e3gai::add(const e3gai &a, const e3gai &b) {
	float const *pa[4], *pb[4];
	float *pc[4];
	int gu = a.gradeUsage() | b.gradeUsage();
	setUsage(gu | (e3gai_mvSize[gu] << 4));
	if (a.gradeUsage() == b.gradeUsage()) e3gai_addSameGradeUsage(c, a.c, b.c, memUsage());
	else {
		a.expand(b, pa, pb);
		expand( (const float**) pc);
		e3gai_add(pa, pb, pc);
	}
}

void e3gai::add(float scalar, const e3gai &b) {
	float const *pa[4], *pb[4];
	float *pc[4];
	int gu = GRADE0 | b.gradeUsage();
	setUsage(gu | (e3gai_mvSize[gu] << 4));
	if (GRADE0 == b.gradeUsage()) e3gai_addSameGradeUsage(c, &scalar, b.c, memUsage());
	else {
		memset(pa + 1, 0, sizeof(float) * 3);
		pa[0] = &scalar;
		b.expand(pb);
		expand( (const float**) pc);
		e3gai_add(pa, pb, pc);
	}
}

void e3gai::sub(const e3gai &a, const e3gai &b) {
	float const *pa[4], *pb[4];
	float *pc[4];
	int gu = a.gradeUsage() | b.gradeUsage();
	setUsage(gu | (e3gai_mvSize[gu] << 4));
	if (a.gradeUsage() == b.gradeUsage()) e3gai_subSameGradeUsage(c, a.c, b.c, memUsage());
	else {
		a.expand(b, pa, pb);
		expand( (const float**) pc);
		e3gai_sub(pa, pb, pc);
	}
}

void e3gai::sub(float scalar, const e3gai &b) {
	float const *pa[4], *pb[4];
	float *pc[4];
	int gu = GRADE0 | b.gradeUsage();
	setUsage(gu | (e3gai_mvSize[gu] << 4));
	if (GRADE0 == b.gradeUsage()) e3gai_subSameGradeUsage(c, &scalar, b.c, memUsage());
	else {
		memset(pa + 1, 0, sizeof(float) * 3);
		pa[0] = &scalar;
		b.expand(pb);
		expand( (const float**) pc);
		e3gai_sub(pa, pb, pc);
	}
}

void e3gai::takeGrade(const e3gai &a, int grade) {
	int ia, i, gua, j, gu = grade, mu = e3gai_mvSize[gu];
	if ((gua = a.gradeUsage()) & gu) {
		setUsage(gu | (mu << 4));

		ia = 0; j = 1;
		for (i = 1; i != grade; i = i << 1) {if (gua & j) ia += e3gai_mvSize[j];	j <<= 1;}
		e3gai_copy(c, a.c + ia, mu);
	}
	else setUsage(0);
}

int e3gai::highestGrade(const e3gai &a) {
	int g = 3, gu = a.gradeUsage(), ia = e3gai_mvSize[gu], size, i;
	const float *cptr;
	do {
		if (gu & (1 << g)) {
			size = e3gai_gradeSize[g];
			ia -= size;
			cptr = a.c + ia;
			for (i = 0; i < size; i++) 
				if (cptr[i]) {
					set(1 << g, a.c + ia);
					return g;
				}
		}
	} while ((--g)>0);
	return -1;

	setUsage(0);
	return 0;
}

int e3gai::grade() const { // todo: THIS FUNCTION _IS_ CORRECT 
	int g = 3, gu = gradeUsage(), idx = e3gai_mvSize[gu], size, i;
	const float *cptr;
	do {
		if (gu & (1 << g)) {
			size = e3gai_gradeSize[g];
			idx -= size;
			cptr = c + idx;
			for (i = 0; i < size; i++) if (cptr[i]) return (gu ^ (1 << g)) ? -1 : g;
		}
	} while ((--g)>0);
	return 0;
}
/*
int e3gai::grade() const { // todo: THIS FUNCTION IS INCORRECT (should check for grades equal to zero)
	int g = 3, gu = gradeUsage();
	do if (gu & (1 << g)) return (gu ^ (1 << g)) ? -1 : g;
	while ((--g)>0);
	return 0;
}
*/
int e3gai::maxGrade() const { // todo: THIS FUNCTION _IS_ CORRECT) (checks for grades equal to zero)
	int g = 3, gu = gradeUsage(), idx = e3gai_mvSize[gu], size, i;
	const float *cptr;
	do {
		if (gu & (1 << g)) {
			size = e3gai_gradeSize[g];
			idx -= size;
			cptr = c + idx;
			for (i = 0; i < size; i++) if (cptr[i]) return g;
		}
	} while ((--g)>0);
	return -1;
}

int e3gai::versorInverse(const e3gai &a) {
	e3gai reverse, scalar;
	reverse.reverse(a);
	scalar.scp(a, reverse);
	if (scalar.c[0] == 0.0f) return -1;
	scalar.c[0] = 1.0f / scalar.c[0];
	op(scalar, reverse);
	return 0;
}

int e3gai::lounestoInverse(const e3gai &a) {
	e3gai cc, acc, scalar, pseudoscalar;
	float s, d, coor[2];

	// compute (a * clifford conjugate)
	cc.cliffordConjugate(a);
	acc.gp(a, cc);

	// get scalar and pseudoscalar of acc; compute the square of the pseudoscalar
	s = (acc.usage & 1) ? acc.c[0] : 0.0f;
	pseudoscalar.takeGrade(acc, GRADE3);
	scalar.gp(pseudoscalar, pseudoscalar);

	// compute the denominator
	if ((d = s * s - ((scalar.usage & 1) ? scalar.c[0] : 0.0f)) == 0.0f) return -1;

	// compute the result
	coor[0] = s / d;
	coor[1] = ((pseudoscalar.usage & 8) ? -pseudoscalar.c[0] : 0.0f) / d;
	acc.set(GRADE0 | GRADE3, coor);
	gp(cc, acc);

	return 0;
}

void e3gai::expand(float matrix[], const int table[]) const {
	float val;
	int i, j = 0, t, g = -1, gi = 0, gu = gradeUsage(), ci = 0;
	for (i = -1; i < 8; i++) {
		if (i == -1) val = 0.0f;
		else {
			if (gi == 0) gi = e3gai_gradeSize[++g];
			if (gu & (1 << g)) val = c[ci++];
			else val = 0.0f;
			gi--;
		}
		while ((t = table[j++]) >= 0) {
			if (t & 128) matrix[t & 63] += (t & 64) ? -val : val;
			else matrix[t & 63] = (t & 64) ? -val : val;
		}
	}
}

int e3gai::generalInverse(const e3gai &a) {
	static float matrix[64];
	static float *m[8] = {
		matrix + 0,
		matrix + 8,
		matrix + 16,
		matrix + 24,
		matrix + 32,
		matrix + 40,
		matrix + 48,
		matrix + 56

	};
	float maxp, *tmp, mult;
	int pi, i, j, k;
	float inverse[8];
	inverse[0] = 1.0f;
	memset(inverse + 1, 0, (8-1) * sizeof(float));
	int it = 0;

	a.expand(matrix, e3gai_expansionTable_gp);

	for (i = 0; i < 8; i++) {	// sweep all columns
		pi = i;
		maxp = fabsf(m[i][i]);

		for (j = i + 1; j < 8; j++) // find the max pivot
			if ((float)fabsf(m[j][i]) > maxp)
				maxp = (float)fabsf(m[pi = j][i]);
		if (inverse[pi] != 0.0f) it = 1;
		if (pi != i) { // swap rows
			if (inverse[i] != 0.0f) it = 1;
			tmp = m[pi]; m[pi] = m[i]; m[i] = tmp;
			if (it) maxp = inverse[pi]; inverse[pi] = inverse[i]; inverse[i] = maxp;
		}

		maxp = m[i][i];
		if (maxp == 0.0f) {	// singular matrix
			setUsage(0);
			return -1;
		}

		for (k = 0; k < 8; k++) { // sweep all other rows
			if (k == i) continue;
			mult = -m[k][i] / maxp;
			for (j = i + 1; j < 8; j++) m[k][j] += m[i][j] * mult;
			if (it) inverse[k] += inverse[i] * mult;
		}

		for (j = i+1; j < 8; j++) m[i][j] /= maxp; // divide the pivot row
		if (it) inverse[i] /= maxp;
	}
	set((1 << 4) - 1, inverse);
	return 0;
}

float e3gai::norm_a() const {
	return e3gai_norm_a(c, e3gai_mvSize[gradeUsage()]);
}

void e3gai::normalize(const e3gai &a, int norm) {
	e3gai scalar(GRADE0, 0.0);
	switch(norm) {
	case 1:
		scalar.c[0] = 1.0f / sqrt(a.norm_a());
		break;
	}
	op(a, scalar);
}

int e3gai::project(const e3gai &blade, const e3gai &a) {
	e3gai tmp, bladeInverse;
	bladeInverse.versorInverse(blade);
	tmp.lcont(a, blade);
	lcont(tmp, bladeInverse);
	return 0;
}

int e3gai::projectOntoVersor(const e3gai &versor, const e3gai &a) {
	e3gai tmp, versorInverse;
	versorInverse.versorInverse(versor);
	tmp.lcont(a, versor);
	gp(tmp, versorInverse);
	return 0;
}

int e3gai::reject(const e3gai &blade, const e3gai &a) {
	e3gai tmp, bladeInverse;
	// todo: check if this code is correct
	bladeInverse.versorInverse(blade);
	tmp.op(blade, a);
	lcont(bladeInverse, tmp);
	return 0;
}

// todo: ensure everything is euclidean...
int e3gai::factor(e3gai factors[], int versor /* = 0 */) const {
	e3gai ca[2], tmp, fi, bv;
	int ga = (versor) ? maxGrade() : grade(), n = 0, i, idx, cca = 0, gu = gradeUsage(), bev;
	float maxC, tmpC, mul, *c2;
	const float *c;
	static float bvc[3] = {1.0, 0.0, 0.0};
	//	extern double pow(double x, double y);

	if (ga <= 0) return 0;

	// compute the multiplication factor require to make every factor of the same order of magnitude
	//	mul = pow(sqrt(norm_a()), 1.0 / ga);
	fprintf(stderr,"Uh, oh!  pow!\n");
	exit(1);

	// setup current 'a'
	ca[0].copy(*this);

	// get the coordinate array for grade 'ga'
	c = coordinates(1 << ga);

	// find out the maximum coordinate
	maxC = (float)fabsf(c[idx = 0]);
	for (i = 1; i < e3gai_gradeSize[ga]; i++) 
		if ( (tmpC = (float)fabsf(ca[cca].c[i])) > maxC) {maxC = tmpC;idx = i;}

	// find out which basis vectors we have to project onto the blade
	idx += e3gai_mvSize[0xff >> (8 - ga)];
	bev = e3gai_newBevt[idx];

	// setup a basis vector
	bv.setVector(bvc);
	c2 = bv.c;
	idx = 0;

	i = 1;
	for (; ga > 1; ga--) {
		// find the next coordinate
		do { // note: the first coordinate is always skipped; this is note a bug 
			c2[idx++] = 0.0; // direct manipulation of 'bv'; hack
			c2[idx] = 1.0; // direct manipulation of 'bv'; hack
			i <<= 1;
		} while (!(bev & i));

		tmp.project(ca[cca], bv);
		factors[n].op(mul, tmp); // make all factors approximatelly the same size

		// remove the factor from the blade
		fi.versorInverse(factors[n++]); 
		if (versor) ca[cca ^ 1].gp(fi, ca[cca]);
		else ca[cca ^ 1].lcont(fi, ca[cca]);
		cca ^= 1;
	}

	factors[n++].takeGrade(ca[cca], GRADE1);	// the last factor is equal to the remaining vector

	return n;
}


int e3gai::deltaProduct(const e3gai &a, const e3gai &b) {
	e3gai mv1;
	mv1.gp(a, b);
	return this->highestGrade(mv1);
}

int e3gai::join(const e3gai &a, const e3gai &b, int algorithm /*= 1*/) {
	e3gai d, factors[3];
	int gj, ga = a.grade(), gb = b.grade(), gd;

	// determine the grade of the join
	if (ga == 0) { // then the join is equal to b
		op(a, b); return gb;
	}
	else if (gb == 0) { // then the join is equal to a
		op(b, a); return ga;
	}
	else { // the join must be computed
		gd = d.deltaProduct(a, b);
		gj = (ga + gb + gd) >> 1;
		return (algorithm == 1) 
			? joinAlg1(a, b, ga, gb, gd)
			: joinAlg2(a, b, ga, gb, gd);
	}
}

int e3gai::meet(const e3gai &a, const e3gai &b, int algorithm /*= 1*/) {
	e3gai d, factors[3], j, jinv;
	int gj, ga = a.grade(), gb = b.grade(), gd;

	gd = d.deltaProduct(a, b);
	j.join(a, b, algorithm);
	if (jinv.versorInverse(j)) {
		null();
		return 0;
	}
	lcont(d, jinv);
	return (ga + gb - gd) >> 1;
}

// todo: ensure everything is euclidean...
int e3gai::joinAlg2(const e3gai &a, const e3gai &b, int ga, int gb, int gj) {
	e3gai mv1, factors[3];
	int cg, lg, nf; // gj = grade join, gd = grade delta product

	/*
	we pick the highest-dimension blade to start with,
	and factor the other blade
	*/
	e3gai res[4];
	int factorsTried[4];
	float largestNorm = -1.0f, nm;
	if (ga > gb) {
		if ( (nf = b.factor(factors)) != gb) return -1;	// should never happen
		lg = cg = ga;
		res[cg].copy(a);
	}
	else {
		if ( (nf = a.factor(factors)) != ga) return -1;	// should never happen
		lg = cg = gb;
		res[cg].copy(b);
	}

	/*
	Wegde as much factors as we need to get the right grade 
	*/
	factorsTried[cg] = 0;
	while (1) {
		// should we lower the current grade, and try the next factor?
		while (factorsTried[cg] >= nf) cg--;
		if (cg < lg) break;

		// wegde a factor to the result
		res[cg + 1].op(res[cg], factors[factorsTried[cg]]);
		factorsTried[cg + 1] = ++(factorsTried[cg]);
		cg++;

		if (cg == gj) {	// if we have arrived at the grade of the join:
			if ( (nm = res[cg].norm_a()) > largestNorm) {
				largestNorm = nm;
				copy(res[cg]);
			}
			cg--;
		}
	}

	return gj;
}

//todo: adjust this version to also support the join/meet/delta product
int e3gai::joinAlg1(const e3gai &a, const e3gai &b, int ga, int gb, int gj) {
	e3gai mv1, b1, b2, factors[3];
	int i, rg, gs; // gj = grade join, gd = grade delta product, rg = required grade, gs = grade size

	/* we pick the highest-dimension blade (b1) to start with */
	e3gai be, pbe, tmp; // be = basis element, pbe = projected basis element
	float v1[3];
	float largestNorm = -1.0f, nm;
	if (ga > gb) {
		b1.copy(a);
		rg = gj - ga;
		b2.copy(b);
	}
	else {
		b1.copy(b);
		rg = gj - gb;
		b2.copy(a);
	}

	// project all possible basis elements of grade 'rg' onto blade b2; wegde them with b1
	gs = e3gai_gradeSize[rg];
	memset(v1, 0, gs * sizeof(float));
	be.set(1 << rg, v1);
	for (i = 0; i < gs; i++) {
		be.c[i] = 1.0f;	// hack
		if (i) be.c[i-1] = 0.0f; // hack
		pbe.project(b2, be);
		tmp.op(b1, pbe);
		if ( (nm = tmp.norm_a()) > largestNorm) {
			largestNorm = nm;
			copy(tmp);
		}
	}

	return gj;
}


int e3gai::random(int grade, float scale, int versor) {

	scale *= (float)2.0;

	// compute how many vector we have to multiply/wegd
	int nb = -1;
	while (grade) {
		grade >>= 1;
		nb++;
	}
	if (nb < 0) return -1;
	else if (nb == 0) {
		setScalar(scale * ((float)rand() / (float)32767 - (float)0.5));
	}
	else {
		int i, j, ct = 0;
		e3gai rv, tmp[2];
		float v[3], scalar = (float)1.0;

		tmp[0].setScalar(&scalar);
		for (i = 0; i < nb; i++) {
			// create a random vector
			for (j = 0; j < 3; j++)
				v[j] = scale * ((float)rand() / (float)32767 - (float)0.5);
			rv.setVector(v);

			// multiply/wegde it to the result
			if (versor) tmp[ct ^ 1].gp(tmp[ct], rv);
			else tmp[ct ^ 1].op(tmp[ct], rv);

			ct ^= 1;
		}

		copy(tmp[ct]);
	}

	return 0;
}

int e3gai::reciprocalFrame(e3gai f[], const e3gai e[], int nbVectors) {
	int cb = 0, i, err, ca, j;
	float scalar = 1.0f;
	e3gai B[2], Bi, tmp, einv, A[2];

	if ((nbVectors <= 0) || (nbVectors > 3)) return 0;

	// build the blade which is the pseudoscalar for the frame 
	B[cb].copy(e[0]);
	for (i = 1; i < nbVectors; i++) {
		B[cb^1].op(B[cb], e[i]);
		cb ^= 1;
	}

	// computer the inverse of the frame
	if (err = Bi.versorInverse(B[cb])) return err;

	// compute the reciprocal vectors
	for (i = 0; i < nbVectors; i++) {
		ca = 0;

		// compute te right scalar factor
		scalar = (i & 1) ? -1.0f : 1.0f;
		A[ca].setScalar(&scalar);

		// compute the blade, with omision of vector e[i]
		for (j = 0; j < nbVectors; j++) {
			if (j == i) continue;
			A[ca^1].op(A[ca], e[j]);
			ca ^= 1;
		}

		// compute reciprocal vector f[i]
		f[i].lcont(A[ca], Bi);
	}

	return 0;
}

void e3gai::om(const e3gai &a, const e3gai_om &om) {
	int ia = 0;
	setUsage(a.usage);

	if (gradeUsage() & 1) {
		e3gai_opt_om_01x01(om.c + 0, a.c + ia, c + ia);
		ia += 1;
	}

	if (gradeUsage() & 2) {
		e3gai_opt_om_03x03(om.c + 1, a.c + ia, c + ia);
		ia += 3;
	}

	if (gradeUsage() & 4) {
		e3gai_opt_om_03x03(om.c + 10, a.c + ia, c + ia);
		ia += 3;
	}

	if (gradeUsage() & 8) {
		e3gai_opt_om_01x01(om.c + 19, a.c + ia, c + ia);
		ia += 1;
	}

}

void e3gai::expand(const float *pa[4]) const {
	int ia = 0;
	int i, j = 1;
	for (i = 0; i < 4; i++) {
		if (gradeUsage() & j) {
			pa[i] = c + ia;
			ia += e3gai_gradeSize[i];
		}
		else pa[i] = NULL;
		j <<= 1;
	}
}

void e3gai::expand2i(const e3gai &b, float const *pa[4], float const *pb[4]) const {
	int ia = 0;
	int i, j = 1;
	for (i = 0; i < 4; i++) {
		if (gradeUsage() & j) {
			pa[i] = c + ia;
			pb[i] = b.c + ia;
			ia += e3gai_gradeSize[i];
		}
		else pa[i] = pb[i] = NULL;
		j <<= 1;
	}
}

void e3gai::expand(const e3gai &b, float const *pa[4], float const *pb[4]) const {
	int ia = 0, ib = 0;
	int i, j = 1;
	for (i = 0; i < 4; i++) {
		if (gradeUsage() & j) {
			pa[i] = c + ia;
			ia += e3gai_gradeSize[i];
		}
		else pa[i] = NULL;
		if (b.gradeUsage() & j) {
			pb[i] = b.c + ib;
			ib += e3gai_gradeSize[i];
		}
		else pb[i] = NULL;
		j <<= 1;
	}
}

void e3gai::compress(float coordinates[8]) {
	int i, j, k, l, s, u;
	float cc[8];
	l = k = u = 0;
	for (i = 0; i < 4; i++) {
		s = e3gai_gradeSize[i];
		for (j = 0; j < s; j++)
			if (coordinates[k + j] != 0.0f) {
				u |= (1 << i);
				e3gai_copy(cc + l, coordinates + k, s);
				l += s;
				break;
			}
		k += s;
	}
	setUsage(u | (l << 4));
	e3gai_copy(c, cc, l);
}

const float *e3gai::coordinates(int grade) const {
	int ia = 0;
	int i, j = 1, gu = gradeUsage();
	static const float null[8]={0.,0.,0.,0.,0.,0.,0.,0.};
	for (i = 0; i < 4; i++) {
		if (j == grade) return (gu & j) ? c + ia : null;
		if (gu & j) ia += e3gai_gradeSize[i];
		j <<= 1;
	}
	return null;
}

void e3gai::gp(const e3gai &a, const e3gai &b) {
	float const *pa[4], *pb[4];
	float cc[8];
	int u, i = e3gai_map_gp_a[a.gradeUsage()] | e3gai_map_gp_b[b.gradeUsage()];

	if ( (u = e3gai_resultUsage_gp[i]) >= 0) {
		setUsage(u);
		e3gai_func_gp[i](a.c, b.c, c);
	}
	else {
		a.expand(b, pa, pb);
		memset(cc, 0, sizeof(float) * 8);
		((e3gai_genFuncPtr)e3gai_func_gp[i])(pa, pb, cc);
		compress(cc);
	}
}

void e3gai::lcont(const e3gai &a, const e3gai &b) {
	float const *pa[4], *pb[4];
	float cc[8];
	int u, i = e3gai_map_lcont_a[a.gradeUsage()] | e3gai_map_lcont_b[b.gradeUsage()];

	if ( (u = e3gai_resultUsage_lcont[i]) >= 0) {
		setUsage(u);
		e3gai_func_lcont[i](a.c, b.c, c);
	}
	else {
		a.expand(b, pa, pb);
		memset(cc, 0, sizeof(float) * 8);
		((e3gai_genFuncPtr)e3gai_func_lcont[i])(pa, pb, cc);
		compress(cc);
	}
}

void e3gai::op(const e3gai &a, const e3gai &b) {
	float const *pa[4], *pb[4];
	float cc[8];
	int u, i = e3gai_map_op_a[a.gradeUsage()] | e3gai_map_op_b[b.gradeUsage()];

	if ( (u = e3gai_resultUsage_op[i]) >= 0) {
		setUsage(u);
		e3gai_func_op[i](a.c, b.c, c);
	}
	else {
		a.expand(b, pa, pb);
		memset(cc, 0, sizeof(float) * 8);
		((e3gai_genFuncPtr)e3gai_func_op[i])(pa, pb, cc);
		compress(cc);
	}
}

void e3gai::op(float scalar, const e3gai &b) {
	float const *pa[4], *pb[4];
	float cc[8];
	int u, i = e3gai_map_op_a[GRADE0] | e3gai_map_op_b[b.gradeUsage()];

	if ( (u = e3gai_resultUsage_op[i]) >= 0) {
		setUsage(u);
		e3gai_func_op[i](&scalar, b.c, c);
	}
	else {
		b.expand(pb);
		memset(pa + 1, 0, sizeof(float) * 3);
		pa[0] = &scalar;
		memset(cc, 0, sizeof(float) * 8);
		((e3gai_genFuncPtr)e3gai_func_op[i])(pa, pb, cc);
		compress(cc);
	}
}

void e3gai::scp(const e3gai &a, const e3gai &b) {
	float const *pa[4], *pb[4];
	float cc[8];
	int u, i = e3gai_map_scp_a[a.gradeUsage()] | e3gai_map_scp_b[b.gradeUsage()];

	if ( (u = e3gai_resultUsage_scp[i]) >= 0) {
		setUsage(u);
		e3gai_func_scp[i](a.c, b.c, c);
	}
	else {
		a.expand(b, pa, pb);
		memset(cc, 0, sizeof(float) * 8);
		((e3gai_genFuncPtr)e3gai_func_scp[i])(pa, pb, cc);
		compress(cc);
	}
}
void e3gai_opt_zero_result(const float *a, const float *b, float *c) {};

int e3gai::resetProfile() {
	return 0;
}
int e3gai::printProfile(float threshold /* = 2.0 */) {
	return 0;
}

e3gai_om::e3gai_om() {
	memset(c, 0, 20 * sizeof(float));
}

e3gai_om::~e3gai_om() {
}

e3gai_om::e3gai_om(const e3gai vectorImages[3]) {
	initOuterMorphism(vectorImages);
}
e3gai_om::e3gai_om(const e3gai *vectorImages[3]) {
	initOuterMorphism(vectorImages);
}

int e3gai_om::initOuterMorphism(const e3gai vectorImages[3]) {
	const e3gai *vi[3];
	int i;
	for (i = 0; i < 3; i++)
		vi[i] = vectorImages + i;
	return initOuterMorphism(vi);
}

int e3gai_om::initOuterMorphism(const e3gai *vectorImages[3]) {
	int beComputed[8], i, j, k, ic, gs, bei;	// be = Basis Element
	e3gai be[8];
	float scalar = 1.0f;

	// set all vectors
	for (i = 1; i <= 3; i++) {
		be[i].takeGrade(*(vectorImages[i-1]), GRADE1);
		beComputed[i] = 1;
	}

	// compute all the other basis elements
	memset(beComputed + 3 + 1, 0, sizeof(int) * (8 - 3 - 1));
	for (i = 3 + 1; i < 8; i++)
		computeBE(be, beComputed, i);

	// insert all coordinates into the matrix
	ic = 1;
	bei = 1;
	for (i = 1; i <= 3; i++) {
		gs = e3gai_gradeSize[i];
		for (j = 0; j < gs; j++) {
			for (k = 0; k < gs; k++) {
				c[ic + k * gs] = be[bei].c[k];
			}
			ic++;
			bei++;
		}
		ic += gs * (gs-1);
	}
	return 0;
}

int e3gai_om::computeBE(e3gai be[8], int beComputed[8], int idx) {
	int i, j, err;
	e3gai tmp;

	if (!beComputed[i = e3gai_omct[idx * 3 + 0]])
		if (err = computeBE(be, beComputed, i)) return err;
	if (!beComputed[j = e3gai_omct[idx * 3 + 1]])
		if (err = computeBE(be, beComputed, j)) return err;

	if (e3gai_omct[idx * 3 + 2] < 0) {
		tmp.negate(be[i]);
		be[idx].op(tmp, be[j]);
	}
	else {
		be[idx].op(be[i], be[j]);
	}

	beComputed[idx] = 1;

	return 0;
}

int e3gai_om::initSpinor2(const e3gai &Sp) {
	int i;
	e3gai Spi, vectorImages[3], tmp, tmp2;
	Spi.versorInverse(Sp);

	for (i = 0; i < 3; i++) {
		tmp.gp(Sp, *(e3gai::bv[i]));
		tmp2.gp(tmp, Spi);
		vectorImages[i].takeGrade(tmp2, GRADE1);
	}
	
	return initOuterMorphism(vectorImages);
}

#include "gaigenhl.cpp"
