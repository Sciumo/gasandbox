/* header file, generated by gaigen */
#ifndef _e3ga_H_
#define _e3ga_H_

#include <stdio.h>
#include <stdlib.h>
// undefine all definition possibly made in other gaigen header file
// This is important when multiple algebras are used in the same application
#undef GAIM_PRODUCT_GP
#undef GAIM_PRODUCT_LCONT
#undef GAIM_PRODUCT_OP
#undef GAIM_PRODUCT_SCP
#undef GAIM_PRODUCT_IGP
#undef GAIM_PRODUCT_GP_EM
#undef GAIM_PRODUCT_LCONT_EM
#undef GAIM_PRODUCT_OM
#undef GAIM_FUNCTION_GRADEINVOLUTION
#undef GAIM_FUNCTION_REVERSE
#undef GAIM_FUNCTION_NEGATE
#undef GAIM_FUNCTION_ADD
#undef GAIM_FUNCTION_SUBSTRACT
#undef GAIM_FUNCTION_NORM_A
#undef GAIM_FUNCTION_NORMALIZE
#undef GAIM_FUNCTION_TAKEGRADE
#undef GAIM_FUNCTION_VERSORINVERSE
#undef GAIM_FUNCTION_GENERALINVERSE
#undef GAIM_FUNCTION_SPINORPRODUCT
#undef GAIM_FUNCTION_CLIFFORDCONJUGATE
#undef GAIM_FUNCTION_LOUNESTOINVERSE
#undef GAIM_FUNCTION_HIGHESTGRADE
#undef GAIM_FUNCTION_GRADE
#undef GAIM_FUNCTION_OUTERMORPHISM
#undef GAIM_FUNCTION_PROJECT
#undef GAIM_FUNCTION_MEETJOIN
#undef GAIM_FUNCTION_RANDOM
#undef GAIM_FUNCTION_RECIPROCALFRAME
#undef GAIM_FUNCTION_PROFILE
#undef GAIM_FUNCTION_UNDEFINED
#undef GAIM_FUNCTION_UNDEFINED
#undef GAIM_FUNCTION_UNDEFINED
#undef GAIM_FUNCTION_UNDEFINED
#undef GAIM_FUNCTION_UNDEFINED
#undef GAIM_FUNCTION_UNDEFINED
#undef GAIM_FUNCTION_UNDEFINED
#undef GAIM_FUNCTION_UNDEFINED
#undef GAIM_FUNCTION_UNDEFINED
#undef GAIM_FUNCTION_UNDEFINED
#undef GAIM_FUNCTION_UNDEFINED
#undef GAIM_INVERSEPSEUDOSCALAR
#undef GAIM_PSEUDOSCALAR
#undef GAIM_FLOAT
#undef GAIM_CLASSNAME
#undef GAIM_OM_CLASSNAME
#undef GAIM_CONSTRUCTOR_1_COOR
#undef GAIM_CONSTRUCTOR_2_COOR
#undef GAIM_CONSTRUCTOR_3_COOR
#undef GAIM_CONSTRUCTOR_4_COOR
#undef GAIM_CONSTRUCTOR_5_COOR
#undef GAIM_CONSTRUCTOR_6_COOR
#undef GAIM_CONSTRUCTOR_7_COOR
#undef GAIM_CONSTRUCTOR_8_COOR

// what functions/products are implemented (used by superclass):
#define GAIM_PRODUCT_GP
#define GAIM_PRODUCT_IGP
#define GAIM_PRODUCT_GP_EM gp
#define GAIM_PRODUCT_LCONT
#define GAIM_PRODUCT_LCONT_EM lcont
#define GAIM_PRODUCT_OP
#define GAIM_PRODUCT_SCP
#define GAIM_PRODUCT_OM
#define GAIM_FUNCTION_GRADEINVOLUTION
#define GAIM_FUNCTION_REVERSE
#define GAIM_FUNCTION_NEGATE
#define GAIM_FUNCTION_ADD
#define GAIM_FUNCTION_SUBSTRACT
#define GAIM_FUNCTION_NORM_A
#define GAIM_FUNCTION_NORMALIZE
#define GAIM_FUNCTION_TAKEGRADE
#define GAIM_FUNCTION_VERSORINVERSE
#define GAIM_FUNCTION_GENERALINVERSE
#define GAIM_FUNCTION_CLIFFORDCONJUGATE
#define GAIM_FUNCTION_LOUNESTOINVERSE
#define GAIM_FUNCTION_HIGHESTGRADE
#define GAIM_FUNCTION_GRADE
#define GAIM_FUNCTION_OUTERMORPHISM
#define GAIM_FUNCTION_PROJECT
#define GAIM_FUNCTION_MEETJOIN
#define GAIM_FUNCTION_RANDOM
#define GAIM_FUNCTION_RECIPROCALFRAME
#define GAIM_FUNCTION_UNDEFINED
#define GAIM_INVERSEPSEUDOSCALAR e3gai::Ii
#define GAIM_PSEUDOSCALAR e3gai::I
#define GAIM_FLOAT float
#define GAIM_CLASSNAME e3gai
#define GAIM_OM_CLASSNAME e3gai_om

#define GAIM_CONSTRUCTOR_1_COOR
#define GAIM_CONSTRUCTOR_3_COOR

/* grade macros */
#ifndef GRADE0
#define GRADE0 (1 << 0)
#endif
#ifndef GRADE1
#define GRADE1 (1 << 1)
#endif
#ifndef GRADE2
#define GRADE2 (1 << 2)
#endif
#ifndef GRADE3
#define GRADE3 (1 << 3)
#endif


extern "C" {

extern const int e3gai_omct[24];
extern const int *e3gai_bevt[4];
extern const int e3gai_newBevt[8];
extern const char *e3gai_basisElementNames[8];
extern int e3gai_gradeSize[4];
extern int e3gai_mvSize[16];

/* optimized implementations of products with a result of zero: */
extern void e3gai_opt_zero_result(const float *a, const float *b, float *c);

/* optimized implementations of products: (to be compiled from .opt file) */
extern void e3gai_opt_01_op_02(const float *a, const float *b, float *c);
extern void e3gai_opt_02_op_02(const float *a, const float *b, float *c);
extern void e3gai_opt_04_op_02(const float *a, const float *b, float *c);
extern void e3gai_opt_02_lcont_04(const float *a, const float *b, float *c);
extern void e3gai_opt_02_lcont_02(const float *a, const float *b, float *c);
extern void e3gai_general_gp(const float *a[], const float *b[], float *c);
extern void e3gai_general_lcont(const float *a[], const float *b[], float *c);
extern void e3gai_general_op(const float *a[], const float *b[], float *c);
extern void e3gai_general_scp(const float *a[], const float *b[], float *c);

/* mapping from grade usage -> index in fp table & the function pointer table */
typedef void (*e3gai_genFuncPtr)(const float *a[], const float *b[], float *c);
typedef void (*e3gai_optFuncPtr)(const float *a, const float *b, float *c);
extern const int e3gai_map_gp_a[];
extern const int e3gai_map_gp_b[];
extern /*const*/ e3gai_optFuncPtr e3gai_func_gp[]; /* pointers to optimized functions for doing 'gp' products */
extern const int e3gai_resultUsage_gp[]; /* grade & memory usage of results of 'gp' products */
extern const int e3gai_map_lcont_a[];
extern const int e3gai_map_lcont_b[];
extern /*const*/ e3gai_optFuncPtr e3gai_func_lcont[]; /* pointers to optimized functions for doing 'lcont' products */
extern const int e3gai_resultUsage_lcont[]; /* grade & memory usage of results of 'lcont' products */
extern const int e3gai_map_op_a[];
extern const int e3gai_map_op_b[];
extern /*const*/ e3gai_optFuncPtr e3gai_func_op[]; /* pointers to optimized functions for doing 'op' products */
extern const int e3gai_resultUsage_op[]; /* grade & memory usage of results of 'op' products */
extern const int e3gai_map_scp_a[];
extern const int e3gai_map_scp_b[];
extern /*const*/ e3gai_optFuncPtr e3gai_func_scp[]; /* pointers to optimized functions for doing 'scp' products */
extern const int e3gai_resultUsage_scp[]; /* grade & memory usage of results of 'scp' products */
extern void e3gai_opt_om_01x01(const float *a, const float *b, float *c);
extern void e3gai_opt_om_03x03(const float *a, const float *b, float *c);

extern void e3gai_copy(float *dest, const float *src, int length);
extern void e3gai_reverse(float *a[4]);
extern void e3gai_cliffordConjugate(float *a[4]);
extern void e3gai_involution(float *a[4]);
extern void e3gai_negate(float *dest, const float *src, int length);
extern void e3gai_addSameGradeUsage(float *c, const float *a, const float *b, int length);
extern void e3gai_add(const float *a[4], const float *b[4], float *c[4]);
extern void e3gai_subSameGradeUsage(float *c, const float *a, const float *b, int length);
extern void e3gai_sub(const float *a[4], const float *b[4], float *c[4]);
extern float e3gai_norm_a(const float a[], int nb);
} /* end of 'extern "C"' */


class e3gai_om;


class e3gai {
public:
	static e3gai e1;
	static e3gai e2;
	static e3gai e3;
	static e3gai *bv[3];
	static e3gai I;
	static e3gai Ii;

	static const int dim;
	static const int nbCoor;

	e3gai();
	e3gai(const e3gai &a);
	~e3gai();
	e3gai(int gradeUsage, const float *coordinates);
	e3gai(int grade, float c0);
	e3gai(int grade, float c0, float c1, float c2);

	void null();

	void set(int gradeUsage, const float *coordinates);
	void setScalar(const float coordinates[1]);
	void setVector(const float coordinates[3]);
	void set2Vector(const float coordinates[3]);
	void set3Vector(const float coordinates[1]);
	int set(int grade, float c0);
	int set(int grade, float c0, float c1, float c2);
	inline int setScalar(float c0)
		{return set(GRADE0, c0);}
	inline int setVector(float c0, float c1, float c2)
		{return set(GRADE1, c0, c1, c2);}
	inline int set2Vector(float c0, float c1, float c2)
		{return set(GRADE2, c0, c1, c2);}
	inline int set3Vector(float c0)
		{return set(GRADE3, c0);}

	inline float scalar() const {return((gradeUsage() & GRADE0) ? c[0] : (float)0.0);};

	const char *e3gai::string(const char *prec = NULL) const;
	void e3gai::print(const char *text = NULL, const char *prec = NULL) const;
	void e3gai::fprint(FILE *F, const char *text = NULL, const char *prec = NULL) const;

	int usage; /* usage of grades/memory */
	inline int gradeUsage() const {return usage & 0xf;}
	inline int memUsage() const {return (usage>>0x4) & 0xf;}


	void gp(const e3gai &a, const e3gai &b);

	void lcont(const e3gai &a, const e3gai &b);

	void op(const e3gai &a, const e3gai &b);

	void op(float scalar, const e3gai &a);
	inline void op(const e3gai &a, float scalar) {op(scalar, a);};

	void scp(const e3gai &a, const e3gai &b);
	void copy(const e3gai &a);
	void compress(); // compresses (removes all grades which are 0) this multivector in place
	void reverse(const e3gai &a);
	void cliffordConjugate(const e3gai &a);
	void gradeInvolution(const e3gai &a);
	void negate(const e3gai &a);

	void add(const e3gai &a, const e3gai &b);
	void add(float scalar, const e3gai &b);
	inline void add(const e3gai &b, float scalar) {add(scalar, b);};

	void sub(const e3gai &a, const e3gai &b);
	void sub(float scalar, const e3gai &b);
	inline void sub(const e3gai &b, float scalar) {sub(scalar, b);};
	void takeGrade(const e3gai &a, int grade);
	int highestGrade(const e3gai &a);

	int grade() const; // return the grade of 'this', if 'this' is a homogeneous multivector; otherwise it returns -1
	int maxGrade() const; // return the maximum non zero grade of 'this', returns -1 if this = 0

	int versorInverse(const e3gai &a); // compute inverse, for versors only
	int lounestoInverse(const e3gai &a); // compute inverse, for general 3d multivectors
	int generalInverse(const e3gai &a); // compute inverse, for general multivectors; uses gaussian elimination (slower and less stable than versorInverse)
	void om(const e3gai &a, const e3gai_om &om);
	void expand(float matrix[], const int table[]) const;
	float norm_a() const;
	void normalize(const e3gai &a, int norm);

	int project(const e3gai &blade, const e3gai &a);
	int projectOntoVersor(const e3gai &versor, const e3gai &a);
	int reject(const e3gai &blade, const e3gai &a);

	int factor(e3gai factors[], int versor = 0) const;
	inline int factorVersor(e3gai factors[]) const {return factor(factors, 1);};

	int deltaProduct(const e3gai &a, const e3gai &b); // sets this to delta(a, b); returns the grade of the delta product
	int join(const e3gai &a, const e3gai &b, int algorithm = 1); // sets this to join(a, b); returns the grade of the join
	int meet(const e3gai &a, const e3gai &b, int algorithm = 1); // sets this to meet(a, b); returns the grade of the meet
protected:
	int joinAlg1(const e3gai &a, const e3gai &b, int ga, int gb, int gj);
	int joinAlg2(const e3gai &a, const e3gai &b, int ga, int gb, int gj);
public:

	inline int randomBlade(int grade, float scale) {return random(grade, scale, 0);}
	inline int randomVersor(int grade, float scale) {return random(grade, scale, 1);}
	int random(int grade, float scale, int versor);

	static int reciprocalFrame(e3gai f[], const e3gai e[], int nbVectors);

	const float *coordinates(int grade) const;

	float c[8];
protected:
	inline void setUsage(int u) {usage = u;}

	void expand(const float *pa[4]) const;
	void expand2i(const e3gai &b, float const *pa[4], float const *pb[4]) const;
	void expand(const e3gai &b, float const *pa[4], float const *pb[4]) const;
	void compress(float coordinates[8]);

public:
	static int resetProfile();
	static int printProfile(float threshold = 2.0);
};

class e3gai_om {
public:
	e3gai_om();
	~e3gai_om();

//	e3gai_om(const e3gai &Sp); (todo) -> initSpinor2
	e3gai_om(const e3gai vectorImages[3]);
	e3gai_om(const e3gai *vectorImages[3]);
	int initOuterMorphism(const e3gai vectorImages[3]);
	int initOuterMorphism(const e3gai *vectorImages[3]);
	int initSpinor2(const e3gai &Sp);

	float c[20];

protected:
	int computeBE(e3gai be[8], int beComputed[8], int idx);

};
#ifdef CLASSNAME
#undef CLASSNAME
#endif
#define CLASSNAME e3ga
#ifdef CLASSNAME_OM
#undef CLASSNAME_OM
#endif
#define CLASSNAME_OM e3ga_om
#include "gaigenhl.h"
#endif /* _e3gai_H_*/
